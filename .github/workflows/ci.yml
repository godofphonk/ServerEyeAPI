# Copyright (c) 2026 godofphonk
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

name: CI/CD Pipeline

on:
  push:
    branches: [ master, production ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ master, production ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: godofphonk/servereyeapi

jobs:
  # Test and Quality Checks
  test-and-quality:
    name: Tests and Quality Checks
    runs-on: ubuntu-latest
    outputs:
      coverage: ${{ steps.coverage.outputs.percentage }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'
        
    - name: Cache Go modules
      uses: actions/cache@v3
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
          
    - name: Download dependencies
      run: go mod download
      
    - name: Verify dependencies
      run: go mod verify
      
    - name: Run tests
      run: go test -v -coverprofile=coverage.out ./...
      
    - name: Extract coverage percentage
      id: coverage
      run: |
        COVERAGE=$(go tool cover -func=coverage.out | grep total | awk '{print $3}' | sed 's/%//')
        echo "percentage=$COVERAGE" >> $GITHUB_OUTPUT
        echo "üìä Test Coverage: ${COVERAGE}%"
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.out
        flags: unittests
        name: codecov-umbrella
        
    - name: Run security scan
      run: |
        go install github.com/securecodewarrior/gosec/v2/cmd/gosec@latest
        gosec -no-fail -fmt sarif -out results.sarif ./...
      continue-on-error: true
      
    - name: Upload SARIF file
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: results.sarif
      continue-on-error: true
      if: always()
      
    - name: Check for vulnerabilities
      run: |
        go install golang.org/x/vuln/cmd/govulncheck@latest
        govulncheck ./...

  # Lint and Format
  lint:
    name: Code Quality and Linting
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'
        
    - name: Run golangci-lint
      uses: golangci/golangci-lint-action@v6
      with:
        version: 'v1.62.0'
        args: --timeout=10m --disable=errcheck,unused,staticcheck --max-issues-per-linter=0 --max-same-issues=0
        
    - name: Check formatting
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "‚ùå Code is not formatted properly"
          gofmt -s -l .
          exit 1
        fi
        echo "‚úÖ Code is properly formatted"

  # Build Docker Image
  build:
    name: Build and Push Docker Image
    needs: [test-and-quality, lint]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/production' || startsWith(github.ref, 'refs/tags/v')
    
    permissions:
      contents: read
      packages: write
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Set BUILD_DATE and VERSION
      run: |
        echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_ENV
        echo "VERSION=${{ github.sha }}" >> $GITHUB_ENV
        echo "COMMIT_SHA=${{ github.sha }}" >> $GITHUB_ENV
        
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=production,enable={{is_default_branch}}
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          BUILD_DATE=${{ env.BUILD_DATE }}
          VERSION=${{ env.VERSION }}
          COMMIT_SHA=${{ env.COMMIT_SHA }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Verify multi-tier metrics implementation
      run: |
        echo "=== Verifying multi-tier metrics implementation ==="
        
        # Check for key files
        if [ ! -f "internal/services/tiered_metrics.go" ]; then
          echo "‚ùå TieredMetricsService file not found!"
          exit 1
        fi
        
        if [ ! -f "internal/services/metrics_commands.go" ]; then
          echo "‚ùå MetricsCommandsService file not found!"
          exit 1
        fi
        
        if [ ! -f "internal/storage/timescaledb/multi_tier_metrics.go" ]; then
          echo "‚ùå Multi-tier metrics storage file not found!"
          exit 1
        fi
        
        # Check for key implementations
        if ! grep -q "TieredMetricsService" internal/services/tiered_metrics.go; then
          echo "‚ùå TieredMetricsService implementation not found!"
          exit 1
        fi
        
        if ! grep -q "MetricsCommandsService" internal/services/metrics_commands.go; then
          echo "‚ùå MetricsCommandsService implementation not found!"
          exit 1
        fi
        
        echo "‚úÖ Multi-tier metrics implementation verified!"

  # Deploy to Production
  deploy:
    name: Deploy to Production
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/production'
    environment: production
    
    steps:
    - name: Deploy to production
      uses: appleboy/ssh-action@v1.2.5
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USER }}
        key: ${{ secrets.PROD_SSH_KEY }}
        script: |
          set -e
          
          echo "üöÄ Starting deployment to production..."
          
          # Create backup of current deployment
          if [ -d "/opt/servereye" ]; then
            echo "üì¶ Creating backup..."
            sudo cp -r /opt/servereye /opt/servereye.backup.$(date +%Y%m%d_%H%M%S)
          fi
          
          # Ensure directories exist
          sudo mkdir -p /opt/servereye
          cd /opt/servereye
          
          # Pull latest images
          echo "üì• Pulling latest Docker images..."
          sudo docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production
          
          # Update docker-compose.yml with new image
          echo "üìù Updating docker-compose configuration..."
          sudo tee docker-compose.prod.yml > /dev/null <<EOF
          version: '3.8'
          
          services:
            servereye-api:
              image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production
              container_name: servereye-api
              restart: unless-stopped
              ports:
                - "8080:8080"
              environment:
                - HOST=0.0.0.0
                - PORT=8080
                - DATABASE_URL=postgres://postgres:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/servereye?sslmode=disable
                - KEYS_DATABASE_URL=postgres://postgres:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/servereye?sslmode=disable
                - TIMESCALEDB_URL=postgres://postgres:${{ secrets.POSTGRES_PASSWORD }}@timescaledb:5432/servereye?sslmode=disable
                - JWT_SECRET=${{ secrets.JWT_SECRET }}
                - WEBHOOK_SECRET=${{ secrets.WEBHOOK_SECRET }}
                - WEB_URL: ${{ vars.WEB_URL || 'https://api.servereye.dev' }}
                # TimescaleDB configuration
                - TIMESCALEDB_MAX_CONNECTIONS=50
                - TIMESCALEDB_CONN_TIMEOUT=30s
                - TIMESCALEDB_QUERY_TIMEOUT=15s
                - TIMESCALEDB_HEALTH_CHECK_INTERVAL=30s
                # Data retention
                - METRICS_RETENTION_DAYS=90
                - STATUS_RETENTION_DAYS=30
                - EVENTS_RETENTION_DAYS=60
                - COMMANDS_RETENTION_DAYS=30
              volumes:
                - ./logs:/app/logs
              networks:
                - servereye-network
              depends_on:
                postgres:
                  condition: service_healthy
                timescaledb:
                  condition: service_healthy
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
              deploy:
                resources:
                  limits:
                    memory: 1G
                    cpus: '0.5'
                  reservations:
                    memory: 512M
                    cpus: '0.25'
          
            # PostgreSQL for metadata
            postgres:
              image: postgres:15-alpine
              container_name: servereye-postgres
              restart: unless-stopped
              environment:
                POSTGRES_DB: servereye
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
              volumes:
                - servereye_postgres_data:/var/lib/postgresql/data
                - ./deployments:/migrations:ro
              networks:
                - servereye-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 30s
                timeout: 10s
                retries: 3
              deploy:
                resources:
                  limits:
                    memory: 512M
                    cpus: '0.25'
                  reservations:
                    memory: 256M
                    cpus: '0.1'
          
            # TimescaleDB for time-series data
            timescaledb:
              image: timescale/timescaledb:2.15.0-pg15
              container_name: servereye-timescaledb
              restart: unless-stopped
              environment:
                POSTGRES_DB: servereye
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
              volumes:
                - servereye_timescaledb_data:/var/lib/postgresql/data
                - ./deployments/timescaledb-init.sql:/docker-entrypoint-initdb.d/init-timescaledb.sql
              networks:
                - servereye-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 30s
                timeout: 10s
                retries: 3
              command: >
                postgres
                -c shared_preload_libraries=timescaledb
                -c timescaledb.max_background_workers=16
                -c timescaledb.query_chunk_size=200000
                -c max_connections=200
                -c shared_buffers=1GB
                -c effective_cache_size=4GB
                -c maintenance_work_mem=512MB
                -c checkpoint_completion_target=0.9
                -c wal_buffers=64MB
                -c default_statistics_target=100
                -c random_page_cost=1.1
                -c effective_io_concurrency=200
              deploy:
                resources:
                  limits:
                    memory: 4G
                    cpus: '2.0'
                  reservations:
                    memory: 2G
                    cpus: '1.0'
          
          volumes:
            servereye_postgres_data:
              external: true
            servereye_timescaledb_data:
              external: true
          
          networks:
            servereye-network:
              driver: bridge
              ipam:
                config:
                  - subnet: 172.20.0.0/16
          EOF
          
          # Stop existing services
          echo "‚èπÔ∏è Stopping existing services..."
          sudo docker-compose -f docker-compose.prod.yml down || true
          
          # Start new services
          echo "‚ñ∂Ô∏è Starting new services..."
          sudo docker-compose -f docker-compose.prod.yml up -d
          
          # Wait for services to be ready
          echo "‚è≥ Waiting for services to be ready..."
          sleep 30
          
          # Health check
          echo "üè• Performing health check..."
          for i in {1..10}; do
            if curl -f http://localhost:8080/health; then
              echo "‚úÖ Health check passed!"
              break
            else
              echo "‚è≥ Waiting for service to be ready... ($i/10)"
              sleep 10
            fi
          done
          
          # Check logs
          echo "üìã Checking service logs..."
          sudo docker-compose -f docker-compose.prod.yml logs --tail=50
          
          # Clean up old images
          echo "üßπ Cleaning up old Docker images..."
          sudo docker image prune -f
          
          echo "üéâ Deployment completed successfully!"
          echo "üåê Service is available at: http://${{ secrets.PROD_HOST }}:8080"

  # Post-deployment tests
  post-deploy-tests:
    name: Post-deployment Verification
    needs: deploy
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/production'
    
    steps:
    - name: Run post-deployment tests
      run: |
        echo "üß™ Running post-deployment tests..."
        
        # Test health endpoint
        if curl -f http://${{ secrets.PROD_HOST }}:8080/health; then
          echo "‚úÖ Health endpoint is working"
        else
          echo "‚ùå Health endpoint failed"
          exit 1
        fi
        
        # Test metrics endpoints (if available)
        echo "üîç Testing metrics endpoints..."
        
        # Test tiered metrics endpoint
        if curl -f "http://${{ secrets.PROD_HOST }}:8080/api/servers/test-server/metrics/tiered?start=2026-02-14T00:00:00Z&end=2026-02-14T01:00:00Z" > /dev/null 2>&1; then
          echo "‚úÖ Tiered metrics endpoint is working"
        else
          echo "‚ö†Ô∏è Tiered metrics endpoint not available (expected for test environment)"
        fi
        
        echo "‚úÖ Post-deployment tests completed!"
