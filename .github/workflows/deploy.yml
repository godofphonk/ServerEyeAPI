# Copyright (c) 2026 godofphonk
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

name: Build and Deploy

on:
  push:
    branches: [ master, production ]
  pull_request:
    branches: [ master, production ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: godofphonk/servereyeapi

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v6
    
    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version: '1.25'
        
    - name: Cache Go modules
      uses: actions/cache@v5
      with:
        path: ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
        restore-keys: |
          ${{ runner.os }}-go-
          
    - name: Download dependencies
      run: go mod download
      
    - name: Run tests
      run: go test -v ./...
      
    - name: Build
      run: make build

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/production'
    
    permissions:
      contents: read
      packages: write
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v6
      with:
        fetch-depth: 0
        clean: true
        
    - name: Set BUILD_DATE and VERSION
      run: |
        echo "BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_ENV
        echo "VERSION=${{ github.sha }}" >> $GITHUB_ENV
        echo "COMMIT_SHA=${{ github.sha }}" >> $GITHUB_ENV
        
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Build and push Docker image
      run: |
        # Create unique tag
        UNIQUE_TAG="production-${{ github.sha }}-$(date -u +'%Y-%m-%dT%H-%M-%SZ')"
        echo "Building with unique tag: $UNIQUE_TAG"
        
        # Force clean everything
        echo "=== Cleaning git repository ==="
        git clean -fdx
        git reset --hard HEAD
        git fetch --all --prune
        
        # Verify our changes exist
        echo "=== Verifying test changes ==="
        if ! grep -q "CI/CD TEST" internal/websocket/handlers.go; then
          echo "❌ Test changes NOT found in git!"
          exit 1
        fi
        echo "✅ Test changes found in git!"
        
        # Create completely isolated build environment
        echo "=== Creating isolated build environment ==="
        BUILD_DIR="/tmp/servereye-build-$(date +%s)"
        mkdir -p $BUILD_DIR
        cp -r . $BUILD_DIR/
        cd $BUILD_DIR
        
        # Verify files copied correctly
        if ! grep -q "CI/CD TEST" internal/websocket/handlers.go; then
          echo "❌ Test changes NOT found in build directory!"
          exit 1
        fi
        echo "✅ Test changes found in build directory!"
        
        # FORCE CHANGE THE FILE TO BREAK ANY CACHING
        echo "=== Force changing handlers.go to break caching ==="
        echo "// FORCE REBUILD $(date +%s)" >> internal/websocket/handlers.go
        echo "✅ File timestamp and content changed!"
        
        # Verify the change was made
        if ! grep -q "FORCE REBUILD" internal/websocket/handlers.go; then
          echo "❌ Force rebuild comment NOT found!"
          exit 1
        fi
        echo "✅ Force rebuild comment verified!"
        
        # Force rebuild everything
        echo "=== Building Docker image ==="
        docker system prune -a -f
        docker builder prune -a -f
        
        # Build with explicit context and no caching
        docker build \
          --no-cache \
          --pull \
          --force-rm \
          --build-arg BUILD_DATE=${{ env.BUILD_DATE }} \
          --build-arg VERSION=${{ env.VERSION }} \
          --build-arg COMMIT_SHA=${{ env.COMMIT_SHA }} \
          --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$UNIQUE_TAG \
          --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production \
          --tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
          .
        
        # Verify the build
        echo "=== Verifying built image ==="
        
        # Check for FORCE REBUILD comment first - check in source code copied to image
        if ! docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$UNIQUE_TAG test -f /app/internal/websocket/handlers.go || ! docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$UNIQUE_TAG grep -q "FORCE REBUILD" /app/internal/websocket/handlers.go; then
          echo "❌ Force rebuild comment NOT found in source code!"
          echo "Checking if source files exist in image..."
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$UNIQUE_TAG ls -la /app/internal/websocket/ || echo "Directory not found"
          exit 1
        fi
        echo "✅ Force rebuild comment found in source code!"
        
        # Check for CI/CD TEST in source code
        if ! docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$UNIQUE_TAG grep -q "CI/CD TEST" /app/internal/websocket/handlers.go; then
          echo "❌ CI/CD TEST NOT found in source code!"
          echo "Checking source files..."
          docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$UNIQUE_TAG grep -n "TEST" /app/internal/websocket/handlers.go || echo "No TEST found"
          exit 1
        fi
        echo "✅ CI/CD TEST found in source code!"
        
        # Push all tags
        echo "=== Pushing images ==="
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$UNIQUE_TAG
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:production
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        echo "✅ Build and push completed successfully!"

  deploy-production:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/production'
    
    steps:
    - name: Deploy to production
      uses: appleboy/ssh-action@v1.2.4
      with:
        host: ${{ secrets.PROD_HOST }}
        username: ${{ secrets.PROD_USER }}
        key: ${{ secrets.PROD_SSH_KEY }}
        script: |
          # Validate required secrets are available
          if [ -z "${{ secrets.PROD_HOST }}" ] || [ -z "${{ secrets.PROD_USER }}" ] || [ -z "${{ secrets.PROD_SSH_KEY }}" ]; then
            echo "❌ Missing required deployment secrets!"
            exit 1
          fi
          
          cd /opt/servereye
          
          # Validate required files exist on server
          if [ ! -f "./deployments/timescaledb-init.sql" ]; then
            echo "❌ timescaledb-init.sql not found on server!"
            echo "Available files in deployments:"
            ls -la ./deployments/ || echo "Deployments directory not found"
            exit 1
          fi
          echo "✅ timescaledb-init.sql found on server"
          
          # Ensure curl is available for health checks
          if ! command -v curl &> /dev/null; then
            echo "Installing curl for health checks..."
            sudo apt-get update && sudo apt-get install -y curl || sudo yum install -y curl || echo "curl installation failed, using wget"
          fi
          
          # Set variables
          UNIQUE_TAG="production-${{ github.sha }}-$(date -u +'%Y-%m-%dT%H-%M-%SZ')"
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          
          echo "=== Deploying image: $IMAGE_NAME:$UNIQUE_TAG ==="
          
          # Stop services gracefully (preserve data)
          echo "=== Stopping services ==="
          
          # CRITICAL: Create volumes if they don't exist
          echo "=== Creating data volumes ==="
          docker volume create servereye_timescaledb_data || echo "TimescaleDB volume already exists"
          docker volume create servereye_postgres_data || echo "PostgreSQL volume already exists"
          
          # Verify volumes exist after creation
          echo "=== Verifying data volumes exist ==="
          if ! docker volume inspect servereye_timescaledb_data >/dev/null 2>&1; then
            echo "❌ TimescaleDB volume FAILED to create!"
            echo "Available volumes:"
            docker volume ls
            exit 1
          fi
          if ! docker volume inspect servereye_postgres_data >/dev/null 2>&1; then
            echo "❌ PostgreSQL volume FAILED to create!"
            echo "Available volumes:"
            docker volume ls
            exit 1
          fi
          echo "✅ All data volumes exist - safe to proceed"
          
          # Create additional backup before stopping
          echo "=== Creating emergency backup ==="
          mkdir -p /opt/servereye/emergency-backups
          docker run --rm -v servereye_timescaledb_data:/data -v /opt/servereye/emergency-backups:/backup alpine tar czf /backup/emergency_timescaledb_$(date +%Y%m%d_%H%M%S).tar.gz -C /data .
          echo "✅ Emergency TimescaleDB backup created"
          
          # Stop only API service first (keep databases running)
          echo "=== Stopping API service only ==="
          if docker-compose ps | grep -q servereye-api; then
            docker-compose stop servereye-api || true
            docker-compose rm -f servereye-api || true
          fi
          
          # Stop databases only after API is stopped
          echo "=== Stopping database services ==="
          docker-compose down --remove-orphans || true
          
          # Additional cleanup for any remaining containers
          echo "=== Cleaning up remaining containers ==="
          for container in servereye-api servereye-postgres servereye-timescaledb; do
            if docker ps -a -q --filter "name=$container" | grep -q .; then
              docker stop $container || true
              docker rm $container || true
            fi
          done
          
          # Clean up Docker images only (preserve volumes)
          echo "=== Cleaning up Docker images ==="
          docker system prune -a -f
          
          # Pull fresh image
          echo "=== Pulling new image ==="
          docker pull $IMAGE_NAME:production
          
          # Verify image contains our changes in source code
          echo "=== Verifying image contains changes ==="
          if ! docker run --rm $IMAGE_NAME:production test -f /app/internal/websocket/handlers.go || ! docker run --rm $IMAGE_NAME:production grep -q "CI/CD TEST" /app/internal/websocket/handlers.go; then
            echo "❌ Test changes NOT found in production image source!"
            docker run --rm $IMAGE_NAME:production find /app -name "*.go" -type f | head -10 || echo "No Go files found"
            exit 1
          fi
          echo "✅ Test changes found in production image source!"
          
          # Create backup before deployment
          echo "=== Creating backup before deployment ==="
          mkdir -p /opt/servereye/backups
          if docker volume inspect servereye_postgres_data >/dev/null 2>&1; then
            docker run --rm -v servereye_postgres_data:/data -v /opt/servereye/backups:/backup alpine tar czf /backup/postgres_backup_$(date +%Y%m%d_%H%M%S).tar.gz -C /data .
            echo "✅ PostgreSQL backup created"
          fi
          if docker volume inspect servereye_timescaledb_data >/dev/null 2>&1; then
            docker run --rm -v servereye_timescaledb_data:/data -v /opt/servereye/backups:/backup alpine tar czf /backup/timescaledb_backup_$(date +%Y%m%d_%H%M%S).tar.gz -C /data .
            echo "✅ TimescaleDB backup created"
          fi
          
          # Create docker-compose.yml
          cat > docker-compose.yml << 'COMPOSE_EOF'
          services:
            servereye-api:
              image: ghcr.io/godofphonk/servereyeapi:production
              container_name: servereye-api
              restart: unless-stopped
              ports:
                - "8080:8080"
              environment:
                - HOST=0.0.0.0
                - PORT=8080
                - DATABASE_URL=postgres://postgres:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/servereye?sslmode=disable
                - KEYS_DATABASE_URL=postgres://postgres:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/servereye?sslmode=disable
                - TIMESCALEDB_URL=postgres://postgres:${{ secrets.POSTGRES_PASSWORD }}@timescaledb:5432/servereye?sslmode=disable
                - JWT_SECRET=${{ secrets.JWT_SECRET }}
                - WEBHOOK_SECRET=${{ secrets.WEBHOOK_SECRET }}
                - WEB_URL=${{ vars.WEB_URL || 'https://api.servereye.dev' }}
              volumes:
                - ./logs:/app/logs
                - ./.env:/app/.env:ro
              networks:
                - servereye-network
              depends_on:
                postgres:
                  condition: service_healthy
                timescaledb:
                  condition: service_healthy
              healthcheck:
                test: ["CMD-SHELL", "curl -f http://localhost:8080/health || exit 1"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s

            postgres:
              image: postgres:15-alpine
              container_name: servereye-postgres
              restart: unless-stopped
              environment:
                POSTGRES_DB: servereye
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
              volumes:
                - servereye_postgres_data:/var/lib/postgresql/data
                - /opt/servereye/deployments:/migrations:ro
              networks:
                - servereye-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 30s
                timeout: 10s
                retries: 3

            timescaledb:
              image: timescale/timescaledb:2.15.0-pg15
              container_name: servereye-timescaledb
              restart: unless-stopped
              environment:
                POSTGRES_DB: servereye
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
              volumes:
                - servereye_timescaledb_data:/var/lib/postgresql/data
                - /opt/servereye/deployments:/docker-entrypoint-initdb.d:ro
                - /opt/servereye/deployments:/migrations:ro
                - /opt/servereye/deployments/timescaledb-init.sql:/docker-entrypoint-initdb.d/timescaledb-init.sql:ro
              networks:
                - servereye-network
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 30s
                timeout: 10s
                retries: 3

          volumes:
            servereye_postgres_data:
              external: true
            servereye_timescaledb_data:
              external: true

          networks:
            servereye-network:
              driver: bridge
          COMPOSE_EOF

          # Start database services
          echo "=== Starting database services ==="
          docker-compose up -d postgres timescaledb
          
          # Wait for databases to be ready
          echo "=== Waiting for databases to be ready ==="
          sleep 20
          
          # CRITICAL: Verify volumes are properly mounted
          echo "=== Verifying volumes are mounted ==="
          if ! docker-compose exec -T postgres test -d /var/lib/postgresql/data; then
            echo "❌ PostgreSQL volume NOT MOUNTED properly!"
            docker-compose down
            exit 1
          fi
          if ! docker-compose exec -T timescaledb test -d /var/lib/postgresql/data; then
            echo "❌ TimescaleDB volume NOT MOUNTED properly!"
            docker-compose down
            exit 1
          fi
          echo "✅ All volumes mounted correctly"
          
          # Check database health
          echo "=== Checking database health ==="
          timeout 60 bash -c 'until docker-compose exec -T postgres pg_isready -U postgres; do sleep 2; done'
          timeout 60 bash -c 'until docker-compose exec -T timescaledb pg_isready -U postgres; do sleep 2; done'
          
          # Verify TimescaleDB extension
          echo "=== Verifying TimescaleDB extension ==="
          docker-compose exec -T timescaledb psql -U postgres -d servereye -c "SELECT extversion FROM pg_extension WHERE extname = 'timescaledb';" || echo "TimescaleDB extension verification"
          
          # Apply migrations if needed
          echo "=== Applying migrations ==="
          if [ -f "./deployments/migrate.sh" ]; then
            chmod +x ./deployments/migrate.sh
            docker-compose exec -T postgres /bin/bash -c "cd /migrations && ./migrate.sh" || echo "PostgreSQL migration completed or not needed"
          fi
          
          # CRITICAL: Ensure TimescaleDB schema is always present
          echo "=== Ensuring TimescaleDB schema ==="
          # Check if server_metrics table exists
          TABLE_EXISTS=$(docker-compose exec -T timescaledb psql -U postgres -d servereye -t -c "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'server_metrics' AND table_schema = 'public');" | head -1 || echo "f")
          if [ "$TABLE_EXISTS" != "t" ]; then
            echo "TimescaleDB schema missing, applying initialization..."
            # First, ensure TimescaleDB extension is installed
            echo "Installing TimescaleDB extension..."
            docker-compose exec -T timescaledb psql -U postgres -d servereye -c "CREATE EXTENSION IF NOT EXISTS timescaledb;" || echo "TimescaleDB extension installation"
            
            # Apply schema directly from mounted volume
            echo "Checking if timescaledb-init.sql exists..."
            docker-compose exec -T timescaledb ls -la /docker-entrypoint-initdb.d/ || echo "Init directory not found!"
            docker-compose exec -T timescaledb ls -la /docker-entrypoint-initdb.d/timescaledb-init.sql || echo "File not found in init directory!"
            docker-compose exec -T timescaledb ls -la /migrations/ || echo "Migrations directory not found!"
            docker-compose exec -T timescaledb ls -la /migrations/timescaledb-init.sql || echo "File not found in migrations!"
            
            # Check file permissions and content
            echo "Checking file permissions and content..."
            if docker-compose exec -T timescaledb test -f /docker-entrypoint-initdb.d/timescaledb-init.sql; then
              echo "✅ File found in docker-entrypoint-initdb.d"
              docker-compose exec -T timescaledb cat /docker-entrypoint-initdb.d/timescaledb-init.sql | head -5 || echo "Cannot read file content"
              docker-compose exec -T timescaledb psql -U postgres -d servereye -f /docker-entrypoint-initdb.d/timescaledb-init.sql || echo "TimescaleDB init completed from init directory"
            elif docker-compose exec -T timescaledb test -f /migrations/timescaledb-init.sql; then
              echo "✅ File found in migrations directory"
              docker-compose exec -T timescaledb cat /migrations/timescaledb-init.sql | head -5 || echo "Cannot read file content"
              docker-compose exec -T timescaledb psql -U postgres -d servereye -f /migrations/timescaledb-init.sql || echo "TimescaleDB init completed from migrations"
            else
              echo "❌ timescaledb-init.sql not found in container!"
              echo "Available files in /docker-entrypoint-initdb.d:"
              docker-compose exec -T timescaledb ls -la /docker-entrypoint-initdb.d/ || echo "Cannot list init directory"
              echo "Available files in /migrations:"
              docker-compose exec -T timescaledb ls -la /migrations/ || echo "Cannot list migrations"
              echo "Checking root directory:"
              docker-compose exec -T timescaledb ls -la / || echo "Cannot list root"
              exit 1
            fi
            
            # Verify schema was applied
            sleep 5
            TABLE_EXISTS_AFTER=$(docker-compose exec -T timescaledb psql -U postgres -d servereye -t -c "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'server_metrics' AND table_schema = 'public');" | head -1 || echo "f")
            if [ "$TABLE_EXISTS_AFTER" = "t" ]; then
              echo "✅ TimescaleDB schema applied successfully!"
            else
              echo "❌ TimescaleDB schema application failed!"
              docker-compose exec -T timescaledb psql -U postgres -d servereye -c "\dt" || echo "Cannot list tables"
              exit 1
            fi
          else
            echo "✅ TimescaleDB schema already exists"
          fi
          
          # Start main application
          echo "=== Starting main application ==="
          docker-compose up -d servereye-api
          
          # Wait for API to be ready
          echo "=== Waiting for API to start ==="
          sleep 15
          
          # Verify API can connect to TimescaleDB
          echo "=== Verifying API TimescaleDB connectivity ==="
          sleep 15
          # Give more time for logs to appear
          if docker logs servereye-api 2>&1 | grep -q "TimescaleDB client connected successfully" || docker logs servereye-api 2>&1 | grep -q "database.*connected"; then
            echo "✅ API connected to database successfully!"
          else
            echo "⚠️ Database connection check inconclusive, continuing..."
            echo "Recent API logs:"
            docker logs servereye-api --tail 20
          fi
          
          # Wait for services
          echo "=== Waiting for services to start ==="
          sleep 30
          
          # Check if containers are running
          echo "=== Checking container status ==="
          docker-compose ps
          
          # Health check
          echo "=== Performing health check ==="
          for i in {1..6}; do
            echo "Health check attempt $i..."
            if curl -f http://localhost:8080/health; then
              echo "✅ Health check passed!"
              break
            else
              echo "Health check failed, retrying in 10s..."
              sleep 10
              if [ $i -eq 6 ]; then
                echo "❌ Health check failed after 6 attempts!"
                docker logs servereye-api --tail 50
                docker logs servereye-timescaledb --tail 20
                docker logs servereye-postgres --tail 20
                docker-compose ps
                exit 1
              fi
            fi
          done
          
          # Check for CI/CD TEST logs
          echo "=== Checking for CI/CD TEST logs ==="
          sleep 5
          # Give more time and check more patterns
          if docker logs servereye-api 2>&1 | grep -q "CI/CD TEST" || docker logs servereye-api 2>&1 | grep -q "TEST.*CI/CD"; then
            echo "✅ CI/CD TEST logs found!"
          else
            echo "⚠️ CI/CD TEST logs not found yet, checking source code verification..."
            # Final verification that our changes are in the running container
            if docker exec servereye-api test -f /app/internal/websocket/handlers.go && docker exec servereye-api grep -q "CI/CD TEST" /app/internal/websocket/handlers.go; then
              echo "✅ CI/CD TEST found in source code - deployment successful!"
            else
              echo "❌ CI/CD verification failed!"
              docker logs servereye-api --tail 30
              exit 1
            fi
          fi
          
          # CRITICAL: Verify TimescaleDB data persistence
          echo "=== Verifying TimescaleDB data persistence ==="
          sleep 5
          # Check if server_metrics table exists and has data
          TABLE_EXISTS=$(docker-compose exec -T timescaledb psql -U postgres -d servereye -t -c "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'server_metrics' AND table_schema = 'public');" | head -1 || echo "f")
          if [ "$TABLE_EXISTS" != "t" ]; then
            echo "❌ server_metrics table NOT FOUND - DATA LOST!"
            docker-compose exec -T timescaledb psql -U postgres -d servereye -c "\dt" || echo "Cannot list tables"
            exit 1
          fi
          echo "✅ server_metrics table exists - Schema preserved!"
          
          # Check for recent data
          RECENT_COUNT=$(docker-compose exec -T timescaledb psql -U postgres -d servereye -t -c "SELECT COUNT(*) FROM server_metrics WHERE time > NOW() - INTERVAL '1 hour';" | head -1 || echo "0")
          echo "✅ Recent metrics count (last hour): $RECENT_COUNT"
          
          # Final cleanup
          docker image prune -f
          echo "✅ Production deployment successful!"